<?xml version="1.0" encoding="UTF-8"?>

<!--
	@package xpotronix
	@version 2.0 - Areco 
	@copyright Copyright &copy; 2003-2011, Eduardo Spotorno
	@author Eduardo Spotorno
 
	Licensed under GPL v3
	@license http://www.gnu.org/licenses/gpl-3.0.txt
-->

<database>

   <table name="imagen"><!--{{{-->

<code mode="events" type="js"><![CDATA[

function imagen_cambia_imagen() {/*{{{*/

	var img, r;

	if ( ! ( img = Ext.get('xbox_imagen_xpForm') ) ) return;

	if ( r = this.cr() ) {

                /* img.dom.src 	= App.feat.uri_thumb + r.data.dirname + '/' + r.data.basename + '&filtr[]=' + r.data.color + '&wp=900&hl=600&ar=x'; */
                img.dom.src 	= App.feat.uri_thumb + r.data.dirname + '/' + r.data.basename;
		img.dom.border 	= 0;
		img.dom.alt 	= r.data.imagen_ID_label;
                
	} else img.dom.src = 'images/encabezado_pedido.jpg';


}/*}}}*/

	var imagen_init = function() {/*{{{*/

	var panel;

	if ( panel = Ext.getCmp('imagen_xpForm') ) {

		panel.store.on('changerowindex', imagen_cambia_imagen );
		panel.store.on('load', imagen_cambia_imagen );
		panel.on('afterlayout', imagen_cambia_imagen, panel.store );
	}

	panel = Ext.getCmp('imagen_xpThumbs');

	if ( ! panel ) return;

	panel.dv.on('dblclick', function() { 

		this.get_inspect_panel() && this.inspect_window();

	}, panel.obj );


	};/*}}}*/

	imagen_init();

]]>
</code>

	   <code type="php" mode="class_functions"><![CDATA[

	   function main_sql() {/*{{{*/
	   	
		global $xpdoc;

	      // DEBUG: problema de performance
	      // $this->sql->addOrder( 'imagen.fecha' );
	      // $this->sql->addOrder( 'imagen.usuario_ID' );
	      // $this->sql->addOrder( 'imagen.filename DESC' );
	      $this->sql->addOrder( 'imagen.filename' );

	   }/*}}}*/

	function source_path() {/*{{{*/

		global $xpdoc;
		return $this->feat->path_imagenes. '/'.  $this->dirname. '/'. $imagen->basename;

	}/*}}}*/

	function cargar_imagenes() {

	global $xpdoc;

	require_once 'xpthumb.class.php';
	$image = new xpthumb;

	$file_utils = $xpdoc->get_instance('file_utils');

	$legajo_dir = $xpdoc->instance( 'C3_data' );

	if ( ! $xpdoc->user->get_attr( 'legajo' ) ) {

		M()->error( "El usuario {$xpdoc->user->user_username} no tiene un legajo asociado, no puedo continuar. Consulte con el administrador" );
		return;
	}


	if ( !$legajo_dir->load( array( 'legajo_ID' => $xpdoc->user->legajo ) ) ) {
      
		M()->error( "No hay asociado una ruta de directorio al legajo. Consulte con el administrador" );
		return;
	}

	$encontradas = 0;
	$existentes = 0;
	$faltantes = 0;	

 	set_time_limit( 0 );

	$imagen = $xpdoc->get_instance('imagen');

	$sql = new DBQuery( $this->db );
	$sql->addTable("imagen");
	$sql->addUpdate("encontrada", 0);
	$sql->addWhere("imagen.usuario_ID = '{$xpdoc->user->user_username}'");

	M()->debug( "reset de imagen->encontrada: ". $sql->prepare() ) ;
	$sql->Exec();

	$base_path = $this->feat->path_imagenes;

	$working_path = $base_path . '/'. $legajo_dir->dirname;

	M()->debug( "escaneando imagenes para el usuario". $this->usuario_ID. " y el directorio $working_path" );

	$files = $file_utils->list_directory( $working_path, array( 'jpg', 'JPG', 'TIF' ));

	// por cada entrada ...

	foreach ( $files as $file ) {

		// saca el $base_path

		$full_file = $file;

		$file = str_replace( $base_path.'/', "", $file );

		$params = pathinfo( $file );

		// completa la informacion de la imagen

		$params['fecha'] = date ("Y-m-d", filemtime($full_file));
		$params['usuario_ID'] = $this->usuario_ID;
		$params['basename'] = $params['basename'];
		$params['dirname'] = $params['dirname'];

		// si no existe, la crea

		if ( !$imagen->load( $params ) ) {

			$imagen->bind( $params, true );
			$imagen->fill_primary_key();
			$imagen->encontrada = true;
			$imagen->filesize = filesize( $full_file );
			// $imagen->exim_info = (string) $image;
			$imagen->push_privileges( array( 'add' => 1 ) );
			$imagen->insert();
			M()->debug( "encontrada imagen {$params['dirname']}");
			$encontradas ++;

	 	} else {

			$existentes ++;
			$encontrada = true;
			$imagen->filesize = filesize( $full_file );
			// $imagen->exim_info = (string) $image;
			$imagen->push_privileges( array( 'edit' => 1 ) );
			$imagen->update();
			M()->debug( "imagen existente {$params['dirname']}");
		}

		$imagen->pop_privileges();

		// crea el directorio para cache

		$cache_dir = $base_path.'/'.$params['dirname'].'/cache';

		if ( file_exists( $cache_dir )) {

			M()->debug( "$cache_dir existente.");

		} else {

			M()->debug( "creando directorio $cache_dir");
			$file_utils->mkdir( $cache_dir );
		}
	}
	}]]>
	</code>
   </table><!--}}}-->

<table name="scan_imagen"><!--{{{-->
	<code type="php" mode="class_functions"><![CDATA[

function scan_imagen( $scan_imagen_xml ) {/*{{{*/

	global $xpdoc;

	require_once 'xpthumb.class.php';
	$image = new xpthumb;

	$file_utils = $xpdoc->get_instance('file_utils');

	$this->load( $scan_imagen_xml['ID']);

	if ( !$this->fecha_desde ) {
      
		M()->error( "Debes especificar una fecha para escanear las imagenes. No se puede continuar" );
		return;
	}

	$this->encontradas = 0;
	$this->existentes = 0;
	$this->faltantes = 0;	

 	set_time_limit( 0 );

	$imagen = $xpdoc->get_instance('imagen');

	$sql = new DBQuery( $this->db );
	$sql->addTable("imagen");
	$sql->addUpdate("encontrada", 0);
	$sql->addWhere("imagen.fecha = '{$this->fecha_desde}'");

	M()->debug( "reset de imagen->encontrada: ". $sql->prepare() ) ;
	$sql->Exec();

	$base_path = $this->feat->path_imagenes;

	$working_path = $base_path . '/'. str_replace( '-', '/', $this->fecha_desde );

	M()->debug( "escaneando imagenes para la fecha ". $this->fecha_desde. " y el directorio $working_path" );

	$files = $file_utils->list_directory( $working_path, array( "jpg", "JPG" ));

	// por cada entrada ...

	foreach ( $files as $file ) {

		// saca el $base_path

		$full_file = $file;

		$file = str_replace( $base_path.'/', "", $file );

		$params = pathinfo( $file );

		$file_elems = explode( '/', $params['dirname'] );

		if ( count( $file_elems ) < 4 ) continue;

		// completa la informacion de la imagen

		$params['fecha'] = $file_elems[0]. '-'. $file_elems[1]. '-'. $file_elems[2];
		$params['usuario_ID'] = trim(strtolower($file_elems[3]));
		$params['imagen'] = $params['basename'];

		// si no existe, la crea

		// $image->load( $full_file );

		if ( !$imagen->load( $params ) ) {

			$imagen->bind( $params, true );
			$imagen->fill_primary_key();
			$imagen->encontrada = true;
			$imagen->filesize = filesize( $full_file );
			// $imagen->exim_info = (string) $image;
			$imagen->insert();
			M()->debug( "encontrada imagen {$params['dirname']}");
			$this->encontradas ++;

	 	} else {

			$this->existentes ++;
			$imagen->encontrada = true;
			$imagen->filesize = filesize( $full_file );
			// $imagen->exim_info = (string) $image;
			$imagen->update();
			M()->debug( "imagen existente {$params['dirname']}");
		}

		// crea el directorio para cache

		$cache_dir = $base_path.'/'.$params['dirname'].'/cache';

		if ( file_exists( $cache_dir )) {

			M()->debug( "$cache_dir existente.");

		} else {

			M()->debug( "creando directorio $cache_dir");
			$file_utils->mkdir( $cache_dir );
		}
	}

	$sql = new DBQuery( $this->db );
	$sql->addTable("imagen");
	$sql->addQuery("count(*) as faltantes");
	$sql->addWhere("imagen.fecha = '{$this->fecha_desde}'");
	$sql->addWhere("imagen.encontrada = 0");


	$result = $sql->Exec();

	$this->faltantes = $result->fields['faltantes'];

	$this->store_xml_response();

	M()->user( "Fin del proceso. Encontradas: $this->encontradas, existentes: $this->existentes, faltantes: $this->faltantes." );

}/*}}}*/

function cache_imagen( $scan_imagen_xml ) {/*{{{*/

	global $xpdoc;

	$this->load( $scan_imagen_xml['ID']);

	if ( !$this->fecha_desde ) {
      
		M()->error( "Debes especificar una fecha. Abortando el proceso de scan_imagen()" );
		return;
	}

	set_time_limit( 0 );

	$base_path = $this->feat->path_imagenes;

	$working_path = $base_path . '/'. str_replace( '-', '/', $this->fecha_desde );

	M()->info( "cacheando imagenes para la fecha ". $this->fecha_desde. " y el directorio $working_path" );

	$imagen = $xpdoc->get_instance('imagen');

	$sql = new DBQuery( $this->db );
	$sql->addTable("imagen");
	$sql->addQuery("ID");
	$sql->addOrder("filesize DESC");
	$sql->addWhere("fecha = '{$this->fecha_desde}' and cache = 0");

      $imagenes = $sql->Exec();

	$cacheadas = 1;
	$total = $imagenes->_numOfRows;

	foreach( $imagenes as $fimagen ) {

		$imagen_ID = $fimagen['ID'];

		M()->debug( 'id de la imagen '. $imagen_ID ); 

		if ( ! $imagen->load( $imagen_ID ) ) {

			M()->user( 'no encontre la imagen con ID: ' . $imagen_ID );
			// echo '<pre>'; print_r( $imagen->sql ); exit;
			continue;
		}

		$full_path = $imagen->dirname . '/'. $imagen->basename;

		// $imagen_url = $this->feat->uri_thumb . "/imageneshow-imagenes/$full_path&wp=900&hl=600&ar=x";
		$imagen_url = $this->feat->uri_thumb . "/imageneshow-imagenes/$full_path&wp=900&hl=600&ar=x";

		M()->info("cacheando imagen $cacheadas de $total del archivo $full_path" );

		if ( ! function_exists( 'curl_init' ) ) {

			M()->error( 'CURL no instalado. Por favor, configurar' );
			return NULL;

		}

		$ch = curl_init();

		curl_setopt ($ch, CURLOPT_URL, $imagen_url);
		curl_setopt ($ch, CURLOPT_HEADER, 0);
		curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 0);

		ob_start();
		$return = curl_exec( $ch );
		curl_close ($ch);
		ob_end_clean();
		
		if ( $return ) {

			$imagen->cache = true;
			$imagen->update();

		} else M()->user( 'no pude cachear la imagen '. $full_path );


		$cacheadas++;

	}

	M()->user( 'fin de proceso de cacheo para el dia '. $this->fecha_desde );

}/*}}}*/

	]]></code>
	</table><!--}}}-->

</database>
<!-- vim600: fdm=marker sw=3 ts=8 ai: 
-->

